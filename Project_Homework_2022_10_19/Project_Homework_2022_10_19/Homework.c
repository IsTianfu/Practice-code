#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>


//int main()
//{
//	int a = 0;
//	int b = 0;
//	//scanf函数读取失败的时候会返回EOF（end of file），EOF的本质就是-1
//	//如果读取正常的话，返回的是读取到的数据的个数
//	int ret = scanf("%d %d", &a, &b);
//	printf("ret =%d\n", ret);//打印数据的个数
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//	return 0;
//}


//关键字register
//int main()
//{
//	register int a = 10;//建议把a放入register（寄存器）中，建议作用，不起决定性作用，最终这个a里面的10会不会放入寄存器中完全取决于编译器
//	//但现在的编译器非常聪明，即使没有register在前面，编译器自己也会判断是将内容放到寄存器里面，所以现在的register的意义不大
//
//	return 0;
//}


//关键字typedef
//顾名思义，类型重命名
//typedef unsigned int uint;
//int main()
//{
//	unsigned int age;
//	uint age2;//与上一行代码所表示的意思一模一样，类型重命名
//	return 0;
//}



//关键字static
//静态的，三种用法：1.修饰局部变量    2.修饰全局变量    3.修饰函数
//void test
//{
//	int a = 0;
//    a++;
//	printf("%d\n", a);
//}
//int main()
//{
//	int i = 0;
//	while (i < 10)
//	{
//		test();
//		i++;
//	}
//	return 0;
//}
//加个static修饰，使得临时变量a的生命周期延长与程序生命周期一致（a出作用域不销毁）
//void test
//{
//	static int a = 0;
//	a++;
//	printf("%d\n", a);
//}
//int main()
//{
//	int i = 0;
//	while (i < 10)
//	{
//		test();
//		i++;
//	}
//	return 0;
//}

//#define 定义符号/宏
//#define MAX（）

//int Max(int x, int y)
//{
//	return (x > y ? x : y);
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int m = Max(a, b);
//	printf("%d\n", m);
//	return 0;
//}
// 
// 
// 
// 
//宏的用法
//#define MAX(x,y) (x>y?x:y)
//
//int Max(int x, int y)
//{
//	return (x > y ? x : y);
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int m = MAX(a, b);//宏{MAX(a,b)}会被它的宏体(x>y?x:y)替换
//	printf("%d\n", m);
//	return 0;
//}


//指针
// 1.指针就是地址
// 2.口头语中的指针一般指的是指针变量
//首先要理解内存
//内存是计算机上的一种存储空间8G/16G
//程序运行的时候会载入内存
//程序中如果有数据需要存储
//也会申请内存空间
//在实践中，一个内存单元的大小是1个字节（内存单元的编号称为地址，这个地址在C语言中也称为指针）
/* 以32位机器为例：32根地址线，地址线如果通电，假设低电频为0，高电频为1
00000000000000000000000000000000（全低电频）
00000000000000000000000000000001
00000000000000000000000000000010
...
01111111111111111111111111111111
10000000000000000000000000000000
10000000000000000000000000000001
...
11111111111111111111111111111111
最多可产生2的32次方个这样的二进制序列（将这些序列作为内存单元的编号（地址），可以有2的32次方个地址）
一个地址可以管理一个内存单元的话，就可以管理2的32次方个内存单元，也就是2的32次方个字节的内存空间（4G）
64位机器同上，只是地址线等数字都换成了64，所以64位机器能访问的空间是非常大的，2的32次方个4G（内存空间）
内存单元编号=地址=指针 */
/* int main()
{
	int a = 1;//向内存申请了4个字节
	printf("%d\n",sizeof(a));
	return 0;
}
这4个字节都有地址，地址的2进制序列描述起来太复杂，所以把他们转换为16进制数字
2进制中：0~1
8进制中：0~7
10进制中：0~9
16进制：0~9 a  b  c  d  e  f
           10 11 12 13 14  15
	每4个2进制位转换为一个16进制位
如：1        1        1        1（1111的2进制序列）         如：0010   1101
 2的3次方+2的2次方+2的1次方+2的0次方=15(f)                       2     d(13)
 进制，只是数值的表示形式而已  十进制的：11   11的2进制：1011   11的8进制：13   11的16进制：b   
 若int a =11;  int a = 0xb;(16进制形式）  int a = 013;(8进制形式）   2进制太繁琐太长，不用*/

 
 //打印地址
 /*  int main()
{
	int a = 1;//向内存申请了4个字节
	printf("%p\n", &a);//&:取地址操作符，p：打印地址
	return 0;
}
	4个字节代表有4个内存单元的编号，代表有4个地址，也就有4个指针，但是取出的是a所占内存的4个字节中的第一个字节的地址  */


//存放地址
 /*  int main()
{
	int a = 1;//向内存申请了4个字节
	int *pa = &a;//pa作为一个变量来存放a的地址，加个*表示pa是指针，指向a,a的类型为整型，所以前面写int,所以pa的类型整体来讲是int *
	//而地址又叫指针，所以在C语言中把pa叫做指针变量（指针变量是存放指针（地址）的变量）
	return 0;
}   */


//*pa表示解引用操作，作用就是通过pa中的地址，找到a，*pa就是a
/*   int main()
{
	int a = 1;
	int* pa = &a;
	*pa = 20;//通过pa中的地址，找到a，改变a的值
	printf("%d\n", a);
	return 0;
}
举一反三
int main()
{
	char ch = 'w';
	char* pc = &ch;
	//通过pc把ch的值改成 'b'
	*pc = 'b';
	printf("%c\n", *pc);打印b
	ch = 'q';//当ch发生变化，*pc也随之变化
	printf("%c\n", *pc);//打印q
	return 0;
}    */

//一个指针变量的大小是多少
/*   int main()
{
	char* pc;
	int* pi;
	printf("%zd\n", sizeof(pc));//pc虽然指向字符，但其实是存的那个字符的地址，所以大小还是4（x86平台）或者8（x64平台）字节
	printf("%zd\n", sizeof(pi));//不管指向的是是什么类型，但只要是地址那么都是4字节或者8字节
	return 0;
}
%zd是打印无符号的整型，因为sizeof返回的数字是无符号的   */




//作业1.输入一个班级5个学生各5科成绩，输出5个学生各5科成绩及总分。
//输入描述：五行，每行输入一个学生各5科成绩（浮点数表示，范围0.0~100.0），用空格分隔。
//输出描述：五行，按照输入顺序每行输出一个学生的5科成绩及总分（小数点保留1位），用空格分隔。
//输入：
//98.5 96.0 100 99 88
//60.5 77 88.5 99 60
//80 80.5 89 91 92
//93 94 95.5 96 97.5
//100 98 88.5 88 78.5

//输出：
//98.5 96.0 100.0 99.0 88.0 481.5
//60.5 77.0 88.5 99.0 60.0 385.0
//80.0 80.5 89.0 91.0 92.0 432.5
//93.0 94.0 95.5 96.0 97.5 476.0
//100.0 98.0 88.5 88.0 78.5 453.0

/*int main()
{
	int i = 0;
	int j = 0;
	double arr[5][6];
	for (i = 0; i < 5; i++)
	{
		for (j = 0; j < 5; j++)
		{
			scanf("%lf", &arr[i][j]);
		}
		arr[i][5] = (arr[i][0] + arr[i][1] + arr[i][2] + arr[i][3] + arr[i][4]);
	}
	for (i = 0; i < 5; i++)
	{
		for (j = 0; j < 6; j++)
		{
			printf("%.1lf ", arr[i][j]);//.1：保留一位小数（数字1，不是字母l）
		}
		printf("\n");
	}
	return 0;
}*/


//写法2.

/*int main()
{
	double score[5] = { 0.0 };
	int i = 0;
	while (i < 5)
	{
		int j = 0;
		double sum = 0.0;
		while (j < 5)
		{
			scanf("%lf", &score[j]);
			sum += score[j];
			j++;
		}
		j = 0;
		while (j < 5)
		{
			printf("%.1lf ", score[j]);
			j++;
		}
		printf("%.1lf\n", sum);
		i++;
	}
    return 0;
}*/


//写法3.
/*int main()
{
	double a, b, c, d, e;
	while (scanf("%lf %lf %lf %lf %lf", &a, &b, &c, &d, &e) ==5)//==5是因为输入了五个值，==1就是只有输入一个值，最好的选择是直接写!= EOF
	{
		float sum = a + b + c + d + e;
		printf("%.1lf %.1lf %.1lf %.1lf %.1lf %.1lf\n", a, b, c, d, e, sum);
	}
	return 0;
}*/





//作业2.KiKi学习了循环，BoBo老师给他出了一系列打印图案的练习，该任务是打印用“ * ”组成的线段图案。
//输入描述：多组输入，一个整数（1~100），表示线段长度，即“ * ”的数量。
//输出描述：针对每行输入，输出占一行，用“ * ”组成的对应长度的线段。
//示例1     输入：10
//                2
//          输出：
//                **********
//                **

/*int main()
{
	int a = 0;
	while (scanf("%d", &a) != EOF)//只要输入的值个数不为0（EOF的本质是-1），就可以循环输入
	{
		int i = 0;
		while (i<a)
		{
			printf("*");
			i++;
		}
		printf("\n");
	}
	return 0;
}*/






//作业3.给定秒数 seconds ，把秒转化成小时、分钟和秒。数据范围： 0 < seconds < 100000000\0 < seconds < 100000000
//输入描述：一行，包括一个整数，即给定的秒数。
//输出描述：一行，包含三个整数，依次为输入整数对应的小时数、分钟数和秒数（可能为零），中间用一个空格隔开。
//示例1    输入：3661    输出：1 1 1


int main()
{
	int a = 0;
	scanf("%d", &a);
	printf("%d %d %d", a / 3600, (a % 3600) / 60, (a % 3600) % 60);
	return 0;
}




































