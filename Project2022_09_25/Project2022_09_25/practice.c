#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <windows.h>
#include <time.h>



//函数的声明和定义

//函数声明：1.告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但具体是不是存在，无关紧要
//          2.函数的声明一般出现在函数的使用之前，要满足先声明后使用
//          3.函数的声明一般要放在头文件中的

//函数的定义：1.函数的定义是指函数的具体实现，交待函数的功能实现
//            2.函数的定义一般放在

//int main()
//{
//	int a = 10;
//	int b = 20;
	//函数声明一下 ――告知
	/*int Add(int, int);

	int c = Add(a, b);
	printf("%d\n", c);
	return 0;
}*/

//函数的定义
//int Add(int x, int y)
//{
//	return x + y;
//}

//模块化
//做一个计算机器（加减）
// A同学写加法，B同学写减法，C同学来集成各模块 

//将模块集成
//#include "add.h"//相当于把头文件里面的所有内容复制过来
//#include "sub.h"
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//int c = Add(a, b);
//	int c = Sub(a, b);
//	printf("%d\n", c);
//	return 0;
//}



//函数递归：程序调用自身的编程技巧称为递归。递归做为一种算法在程序设计语言中广泛应用。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。
//递归的主要思考方式在于：把大事化小

//递归的两个必要条件
//1.存在限制条件，当满足这个限制条件的时候，递归便不在继续
//2.每次递归调用之后越来越接近这个限制条件


//史上最简单的递归
//函数自己调用自己
//int main()
//{
//	printf("呵呵\n");
//	main();
//	return 0;
//}
//上面的代码错误的递归示范(栈溢出），但它确实时属于递归的一种，这么写代码时不对的


//练习1.接受一个整型值（无符号），按照顺序打印它的每一位。如：输入123，输出1 2 3 

void print(unsigned int n)//不要返回类型，因为能把num的每一位打到屏幕上就行，不需要返回什么值
{
	if (n > 9)//递归限制条件
	{
		print(n / 10);//n/10不是取余数，而是取最大除数（商），n%10才是取余数，使n不断逼近限制条件
	}
	printf("%d ", n % 10);
}
int main()
{
	unsigned int num = 0;
	scanf("%u", &num);//输入123,%u叫无符号整型
	//递归――函数自己调用自己
	print(num);//print可以打印参数(num)部分数字的每一位（按顺序）
	return 0;
}


//写递归代码的时候：（预防栈溢出）
//1.不能死递归，都有跳出条件，每次递归逼近跳出条件
//2.递归层次不能太深
//3.www.stackoverflow.com(程序员的知乎）